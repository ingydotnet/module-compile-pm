=pod

=for comment
DO NOT EDIT. This Pod was generated by Swim v0.1.31.
See http://github.com/ingydotnet/swim-pm#readme

=encoding utf8

=head1 NAME

Module::Compile - Perl Module Compilation

=for html
<a href="https://travis-ci.org/ingydotnet/module-compile-pm"><img src="https://travis-ci.org/ingydotnet/module-compile-pm.png" alt="module-compile-pm"></a>
<a href="https://coveralls.io/r/ingydotnet/module-compile-pm?branch=master"><img src="https://coveralls.io/repos/ingydotnet/module-compile-pm/badge.png" alt="module-compile-pm"></a>

=head1 SYNOPSIS

    package Foo;
    use Module::Compile -base;

    sub pmc_compile {
        my ($class, $source) = @_;
        # Convert $source into (most likely Perl 5) $compiled_output
        return $compiled_output;
    }

In C<Bar.pm>:

    package Bar;

    use Foo;
    ...
    no Foo

or (implied "no Foo;"):

    package Bar;

    {
        use Foo;
        ...
    }

To compile C<Bar.pm> into C<Bar.pmc>:

    perl -c Bar.pm

=head1 DESCRIPTION

This module provides a system for writing modules that I<compile> other
Perl modules.

Modules that use these compilation modules get compiled into some altered form
the first time they are run. The result is cached into C<.pmc> files.

Perl has native support for C<.pmc> files. It always checks for them, before
loading a C<.pm> file.

=head1 EXAMPLE

You can declare a C<v6.pm> compiler with:

    package v6;
    use Module::Compile -base;

    sub pmc_compile {
        my ($class, $source) = @_;
        # ... some way to invoke pugs and give p5 code back ...
    }

and use it like:

    # MyModule.pm
    use v6-pugs;
    module MyModule;
    # ...some p6 code here...
    no v6;
    # ...back to p5 land...

On the first time this module is loaded, it will compile Perl 6 blocks into
Perl 5 (as soon as the C<no v6> line is seen), and merge it with the Perl 5
blocks, saving the result into a C<MyModule.pmc> file.

The next time around, Perl 5 will automatically load C<MyModule.pmc> when
someone says C<use MyModule>. On the other hand, Perl 6 can run MyModule.pm s
a Perl 6 module just fine, as C<use v6-pugs> and C<no v6> both works in a Perl
6 setting.

The B<v6.pm> module will also check if C<MyModule.pmc> is up to date. If
it is, then it will touch its timestamp so the C<.pmc> is loaded on the
next time.

=head1 BENEFITS

Module::Compile compilers gives you the following benefits:

=over

=item * Ability to mix many source filterish modules in a much more sane manner. Module::Compile controls the compilation process, calling each compiler at the right time with the right data.

=item * Ability to ship precompiled modules without shipping Module::Compile and the compiler modules themselves.

=item * Easier debugging of compiled/filtered code. The C<.pmc> has the real code you want to see.

=item * Zero additional runtime penalty after compilation, because C<perl> has already been doing the C<.pmc> check on every module load since 1999!

=back

=head1 PARSING AND DISPATCH

NOTE: *** NOT FULLY IMPLEMENTED YET ***

Module::Compile attempts to make source filtering a sane process, by parsing
up your module's source code into various blocks; so that by the time a
compiler is called it only gets the source code that it should be looking at.

This section describes the rather complex algorithm that Module::Compile uses.

First, the source module is preprocessed to hide heredocs, since the content
inside heredocs can possibly confuse further parsing.

Next, the source module is divided into a shallow tree of blocks:

    PREAMBLE:
      (SUBROUTINE | BAREBLOCK | POD | PLAIN)S
    PACKAGES:
      PREFACE
      (SUBROUTINE | BAREBLOCK | POD | PLAIN)S
    DATA

All of these blocks begin and end on line boundaries. They are described
as follows:

=over

=item PREAMBLE

Lines before the first C<package> statement.

=item PACKAGES

Lines beginning with a `package statement and continuing

    until the next `package` or `DATA` section.

=item DATA

The DATA section. Begins with the line C<__DATA__> or

C<__END__>.

=item SUBROUTINE

A top level (not nested) subroutine. Ending '}' must be

on its own line in the first column.

=item BAREBLOCK

A top level (not nested) code block. Ending '}' must be

on its own line in the first column.

=item POD

Pod sections beginning with C<^=\w+> and ending with C<=cut>.

=item PLAIN

Lines not in SUBROUTINE, BAREBLOCK or POD.

=item PREFACE

Lines before the first block in a package.


=back

Next, all the blocks are scanned for lines like:

    use Foo qw'x y z';
    no Foo;

Where Foo is a Module::Compile subclass.

The lines within a given block between a C<use> and C<no> statement are marked
to be passed to that compiler. The end of an inner block effectively acts as a
C<no> statement for any compile sections in that block. C<use> statements in a
PREFACE apply to all the code in a PACKAGE. C<use> statements in a PREAMBLE
apply to all the code in all PACKAGES.

After all the code has been parsed into blocks and the blocks have been marked
for various compilers, Module::Compile dispatches the code blocks to the

      compilers. It does so in a most specific to most general order.  So inner
      blocks get compiled first, then outer blocks.

A compiler may choose to declare that its result not be recompiled by some
other containing parser. In this case the result of the compilation is
replaced by a single line containing the hexadecimal digest of the result in
double quotes followed by a semicolon. Like:

    "f1d2d2f924e986ac86fdf7b36c94bcdf32beec15";

The rationale of this is that randoms strings are usally left alone by
compilers. After all the compilers have finished, the digest lines will be
expanded again.

Every bit of the default process described above is overridable by
various methods.

=head1 DISTRIBUTION SUPPORT

Module::Install makes it terribly easy to prepare a module distribution with
compiled .pmc files. See Module::Install::PMC. All you need to do is add this
line to your Makefile.PL:

    pmc_support;

Any of your distrbution's modules that use Module::Compile based modules will
automatically be compiled into .pmc files and shipped with your distribtution
precompiled. This means that people who install your module distribtution do
not need to have the compilers installed themselves. So you don't need to make
the compiler modules be prerequisites.

=head1 SEE ALSO

=over

=item * L<Module::Install>

=item * L<Module::Install::PMC>

=back

=head1 AUTHORS

=over

=item * Ingy döt Net <ingy@cpan.org>

=item * Audrey Tang <audreyt@audreyt.org>

=back

=head1 COPYRIGHT

Copyright 2006-2014. Ingy döt Net.

This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>

=cut
